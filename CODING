Coding Standards
================

If anyone at feels interested enough to write any code for this program despite its absolute stub nature, then this
author suggests sie follow the following recommendations while coding to help keep the code base consistent. This
author edits using Atom with close-to-default settings, in case that helps; the indentation settings below come from
such.

Code Styling
------------

NOTE: this is the ideal; the real thing might not 100% conform to these rules ofc :)

* Indentation: Each indent should be 2 characters.

* Brackets: Brackets should be on the same line as the specifier for the section they enclose.

* Expressions: Infix operators (e.g. "=", "+", etc.) should be single-spaced apart from their operands, with the
               possible exception of the multiplication operator (*).

* Namespaces: Namespaces are used extensively and should mirror the directory structure for the most part. The
              exception is "include" directories which are used to separate the interface of a module - one should not
              include the "include" part in the namespaces! To keep things manageable, when referencing an object from
              a namespace in headers and function declarations, one should use the shortest identifier possible, and
              when referencing it in function bodies, one should obtain it using "using". Do not put "using" in header
              files.

* Includes: Likewise, paths-to-include-files should follow the same rules as (1) and (2) above.

* Identifiers: Class names should begin with "C", interface names with "I", enums with "E" and structs with "S". Class,
               enum, etc. names should have all words first-letter capitalized (e.g. CSomeClass). Methods and variables
               should be named in camelCase, and internal class member variables prefixed with "m_", while constants
               should have "c_" and globals "g_".

* Wrapping: When wrapping long function declarations, particularly in headers, one should chiefly wrap the argument
            list, and to do so in logical chunks as much as possible.

Program Design
--------------

The design of the code is intended to be such as to keep things modular and easily extensible. It is a standard "three
tier" architecture divided into 3 layers, where the list below is organized to indicate that each layer can (and
usually, must) depend on the one mentioned immediately before it, but it should not depend on one two or more layers
back.

For encapsulation purposes, each layer should consist of a number of modules, which in turn may consist of submodules.
Every module and submodule has an interface and implementation packaged physically separate from each other: in
particular, the interface files go in the module's "include" folder, while the implementation goes in a separate folder
named "Impl", which also has a corresponding namespace hierarchy entry.

CMake should also be used as a tool to enforce this encapsulation: in particular, each directory/namespace node that
defines a new module or submodule should have its own CMakeLists.txt which defines it as a library, and should declare
its include folder as PUBLIC, so that it is exported when compiling other modules dependent upon it, while the
implementation files should be PRIVATE.

Finally, the three layers are:

* Data layer: This should contain all code related to saving and loading image files. This should expose in its public
              interface a set of "transfer objects" which are basically just structs that should be comprehensive
              enough to allow for the full transfer of image data but should not require restriction to a particular
              file format, as best as possible.

* Model (or "domain") layer: This should contain all the business logic, i.e. all code that does the "heavy lifting" of
                             image manipulation should go here. Each domain module (called a "model") should organize
                             its implementation code amongst services, data mappers, and domain objects, which should
                             come in 3 folders in the implementation. The services are fronted to the public interface
                             and communicate with the back-end domain objects as well as moving data from domain object
                             to data mapper to persist it to storage. The domain objects are where all the
                             computational logic should go, the services should be strictly about inter-subsystem
                             communication.

* User interface layer: This layer is where that the GUI-related code, including the code to draw images on screen,
                        is & will be located. Currently this is implemented using Qt, but the point of this design is
                        that GUIs could be written for other widget systems as well (e.g. wxWidgets) with minimal to
                        (ideally) no changes to the other layers.

Afterword
---------

Just to note, this document was prepped with a bit of haste and the author was a lil suppressed so if anything's
unclear, just go look over the code and you should see a reasonable example (hopefully) of what is being talked about
above.

ADD (2020 Aug 24): This document and the general layout have been considerably revised to hopefully make them neater.
ADD (2020 Sep 4): Considerable revision of overall coding standard.
